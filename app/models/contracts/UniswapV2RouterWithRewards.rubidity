pragma :rubidity, "1.0.0"

import './Upgradeable.rubidity'
import './UniswapV2Router.rubidity'

contract :UniswapV2RouterWithRewards, is: [:UniswapV2Router, :Upgradeable], upgradeable: true do
  uint256 :public, :feeBPS
  
  mapping ({ address: mapping(address: :uint256) }), :public, :stakedLP
  mapping ({ address: mapping(address: :uint256) }), :public, :rewardDebt
  
  mapping ({ address: :uint256 }), :public, :totalStakedLP
  
  mapping ({ address: :uint256 }), :public, :feePool
  mapping ({ address: :uint256 }), :public, :accRewardsPerShare
  
  constructor(
    _factory: :address,
    _WETH: :address,
    _feeBPS: :uint256,
  ) {
    require(_feeBPS <= 10000, 'Fee cannot be greater than 100%')
    
    s.feeBPS = _feeBPS
    
    UniswapV2Router.constructor(_factory: _factory, _WETH: _WETH)
    Upgradeable.constructor(upgradeAdmin: msg.sender)
  }
  
  function :stakeLP, { lpToken: :address, amount: :uint256 }, :public, returns: :bool do
    lpPair = UniswapV2Pair(lpToken)
    token0 = lpPair.token0()
    token1 = lpPair.token1()
    
    require(token0 == s.WETH || token1 == s.WETH, 'One of the tokens must be WETH')
    require(amount > 0, 'Amount must be greater than 0')
    
    updateStakeAmount(lpToken: lpToken, amount: amount, isStaking: true, user: msg.sender)
  
    ERC20(lpToken).transferFrom(msg.sender, address(this), amount)
  end
  
  function :unstakeLP, { lpToken: :address, amount: :uint256 }, :public, returns: :bool do
    require(s.stakedLP[msg.sender][lpToken] >= amount, 'Insufficient staked amount')
    require(amount > 0, 'Amount must be greater than 0')
    
    updateStakeAmount(lpToken: lpToken, amount: amount, isStaking: false, user: msg.sender)
    
    ERC20(lpToken).transfer(msg.sender, amount)
  end
  
  function :withdrawRewards, { lpToken: :address }, :public do
    updateStakeAmount(lpToken: lpToken, amount: 0, isStaking: true, user: msg.sender)
  end
  
  function :updateStakeAmount, {
    lpToken: :address,
    amount: :uint256,
    isStaking: :bool,
    user: :address
   }, :internal do
    updateRewards(lpToken: lpToken)

    pending = pendingRewards(user: user, lpToken: lpToken)
    
    require(pending > 0 || amount > 0, 'Nothing to do')
    
    if pending > 0
      ERC20(s.WETH).transfer(user, pending)
    end
    
    if isStaking
      s.stakedLP[user][lpToken] += amount
      s.totalStakedLP[lpToken] += amount
    else
      s.stakedLP[user][lpToken] -= amount
      s.totalStakedLP[lpToken] -= amount
    end
    
    unScaledDebt = s.stakedLP[user][lpToken] * s.accRewardsPerShare[lpToken]
    
    s.rewardDebt[user][lpToken] = unScaledDebt.div(1.ether)
    nil
  end
  
  function :swapExactTokensForTokens, { 
    amountIn: :uint256, 
    amountOutMin: :uint256, 
    path: [:address],
    to: :address, 
    deadline: :uint256 
  }, :public, :virtual, :override, returns: [:uint256] do
    amounts = UniswapV2Router.swapExactTokensForTokens(
      amountIn: amountIn - calculateFeeAmount(amountIn),
      amountOutMin: amountOutMin,
      path: path,
      to: to,
      deadline: deadline
    )
    
    feeInWETH = chargeFeeInWETH(amountIn, path[0])
    
    lpToken = pairFor(factory, path[0], path[1])
    
    s.feePool[lpToken] += feeInWETH
        
    amounts
  end
  
  function :swapTokensForExactTokens, {
    amountOut: :uint256,
    amountInMax: :uint256,
    path: [:address],
    to: :address,
    deadline: :uint256
  }, :public, :virtual, :override, returns: [:uint256] do
    amounts = UniswapV2Router.swapTokensForExactTokens(
      amountOut: amountOut + calculateFeeAmount(amountOut),
      amountInMax: amountInMax,
      path: path,
      to: to,
      deadline: deadline
    )
    
    feeInWETH = chargeFeeInWETH(amountOut, path[1])
    
    lpToken = pairFor(factory, path[0], path[1])
    
    s.feePool[lpToken] += feeInWETH
    
    amounts
  end
  
  function :calculateFeeAmount, { amount: :uint256 }, :public, :virtual, returns: :uint256 do
    return (amount * s.feeBPS).div(10000)
  end
  
  function :calculateAccRewardsPerShare, { lpToken: :address, shouldUpdateState: :bool }, :internal, returns: :uint256 do
    accRewardsPerShare = s.accRewardsPerShare[lpToken]
    
    if s.totalStakedLP[lpToken] > 0 && s.feePool[lpToken] > 0
      accRewardPerShareIncrement = (s.feePool[lpToken] * 1.ether).div(s.totalStakedLP[lpToken])
      accRewardsPerShare += accRewardPerShareIncrement
      
      if shouldUpdateState
        s.accRewardsPerShare[lpToken] = accRewardsPerShare
        s.feePool[lpToken] = 0
      end
    end
    
    return accRewardsPerShare
  end
  
  function :updateRewards, { lpToken: :address }, :internal do
    calculateAccRewardsPerShare(lpToken: lpToken, shouldUpdateState: true)
    nil
  end
  
  function :pendingRewards, { user: :address, lpToken: :address }, :public, :view, returns: :uint256 do
    accRewardsPerShare = calculateAccRewardsPerShare(lpToken: lpToken, shouldUpdateState: false)
    
    topLine = (s.stakedLP[user][lpToken] * accRewardsPerShare).div(1.ether)
    
    return topLine - s.rewardDebt[user][lpToken]
  end
  
  function :chargeFeeInWETH, {
    amount: :uint256,
    token: :address
  }, :internal, :virtual, returns: :uint256 do
    feeAmount = calculateFeeAmount(amount)
    
    if token == s.WETH
      ERC20(token).transferFrom(
        from: msg.sender,
        to: address(this),
        amount: feeAmount
      )
      
      return feeAmount
    end
    
    path = array(:address, 2)
    path[0] = token
    path[1] = s.WETH
    
    feeInWETH = UniswapV2Router.swapExactTokensForTokens(
      amountIn: feeAmount,
      amountOutMin: 0,
      path: path,
      to: address(this),
      deadline: block.timestamp + 1
    )[1]
    
    return feeInWETH
  end
end
