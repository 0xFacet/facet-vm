pragma :rubidity, "1.0.0"

import './Upgradeable.rubidity'
import './UniswapV2Router.rubidity'

contract :UniswapV2RouterWithRewards, is: [:UniswapV2Router, :Upgradeable], upgradeable: true do
  event :RewardClaimed, { user: :address, lpToken: :address, reward: :uint256 }
  
  uint256 :public, :feeBPS
  
  mapping ({ address: mapping(address: :uint256) }), :public, :stakedLP
  mapping ({ address: mapping(address: :uint256) }), :public, :rewardDebt
  
  mapping ({:address => :uint256}), :public, :totalStakedLP
  mapping ({:address => :uint256}), :public, :totalStakeSeconds
  mapping ({:address => :uint256}), :public, :weightedAvgStakeSeconds
  mapping ({:address => :uint256}), :public, :accRewardsPerShare
  mapping ({:address => :uint256}), :public, :lastUpdateTime
  mapping ({:address => :uint256}), :public, :feePool
  
  mapping ({ address: mapping(address: :uint256) }), :public, :weightedAvgStakeTime
  mapping ({ address: mapping(address: :uint256) }), :public, :lastStakeTime
  mapping ({ address: mapping(address: :uint256) }), :public, :firstStakeTime


  constructor(
    _factory: :address,
    _WETH: :address,
    _feeBPS: :uint256,
  ) {
    require(_feeBPS <= 10000, 'Fee cannot be greater than 100%')
    
    s.feeBPS = _feeBPS
    
    UniswapV2Router.constructor(_factory: _factory, _WETH: _WETH)
    Upgradeable.constructor(upgradeAdmin: msg.sender)
  }
  
  function :stakeLP, { lpToken: :address, amount: :uint256 }, :public, returns: :bool do
    lpPair = UniswapV2Pair(lpToken)
    token0 = lpPair.token0()
    token1 = lpPair.token1()
    
    require(token0 == s.WETH || token1 == s.WETH, 'One of the tokens must be WETH')
    
    # Call the internal function to update the staking amount
    updateStakeAmount(lpToken: lpToken, amount: amount, isStaking: true, user: msg.sender)
  
    # Transfer LP tokens from the user to this contract
    ERC20(lpToken).transferFrom(msg.sender, address(this), amount)
  end
  
  function :unstakeLP, { lpToken: :address, amount: :uint256 }, :public, returns: :bool do
    require(s.stakedLP[msg.sender][lpToken] >= amount, 'Insufficient staked amount')
  
    # Call the internal function to update the staking amount
    updateStakeAmount(lpToken: lpToken, amount: amount, isStaking: false, user: msg.sender)
    
    # Transfer LP tokens from this contract back to the user
    ERC20(lpToken).transfer(msg.sender, amount)
  end
  
  function :withdrawRewards, { lpToken: :address }, :public do
    # Call the internal function with an amount of 0 to update and withdraw rewards
    updateStakeAmount(lpToken: lpToken, amount: 0, isStaking: true, user: msg.sender)
  end
  
  # function :pendingRewards2, { user: :address, lpToken: :address }, :public, :view, returns: :uint256 do
  #   ::Kernel.binding.pry
  #   preDebt = (s.stakedLP[user][lpToken] * s.accRewardsPerShare[lpToken]).div(1.ether)
    
  #   return preDebt - s.rewardDebt[user][lpToken]
  # end
  
  # function :pendingRewards, { user: :address, lpToken: :address }, :public, :view, returns: :uint256 do
  #   preDebt = (s.stakedLP[user][lpToken] * s.accRewardsPerShare[lpToken]).div(1.ether)
    
  #   return preDebt - s.rewardDebt[user][lpToken]
  # end
  
  function :updateStakeAmount, ({
    lpToken: :address,
    amount: :uint256,
    isStaking: :bool,
    user: :address }
  ), :internal do
    # Calculate pending rewards for the user
    pending = 0 #pendingRewards(user: user, lpToken: lpToken)
    
    # Distribute pending rewards, if any
    if pending > 0
      ERC20(s.WETH).transfer(user, pending)
      emit :RewardClaimed, user: user, lpToken: lpToken, reward: pending
    end
    
    if (pending > 0 || amount > 0)
      s.lastUpdateTime[lpToken] = block.timestamp
    end
  
    # Update user's weighted average stake-time
    oldStake = s.stakedLP[user][lpToken]
    newStake = isStaking ? (oldStake + amount) : (oldStake - amount)
    oldWeightedTime = s.weightedAvgStakeTime[user][lpToken]
    currentTime = block.timestamp
  
    newWeightedTime = ((oldStake * oldWeightedTime) + (amount * currentTime)).div(newStake)
  
    # Update user's weighted average stake-time
    oldStake = s.stakedLP[user][lpToken]
    newStake = isStaking ? (oldStake + amount) : (oldStake - amount)

    # Initialize oldWeightedTime to 0 if this is the user's first time staking this LP token
    oldWeightedTime = s.weightedAvgStakeTime[user][lpToken] || 0
    currentTime = block.timestamp

    if oldStake == 0 && isStaking
      # First-time staking for this user
      s.firstStakeTime[user][lpToken] = currentTime
      newWeightedTime = 0
    else
      newWeightedTime = ((oldStake * oldWeightedTime) + (amount * currentTime)) / newStake
    end    

    s.weightedAvgStakeTime[user][lpToken] = newWeightedTime
    

    # If it's the first staker, set weightedAvgStakeSeconds directly
    if s.totalStakedLP[lpToken] == 0
      s.weightedAvgStakeSeconds[lpToken] = newWeightedTime
    else
      s.weightedAvgStakeSeconds[lpToken] = (s.weightedAvgStakeSeconds[lpToken] * s.totalStakedLP[lpToken] + newStake * newWeightedTime).div(s.totalStakedLP[lpToken] + newStake)
    end



    # Update totalStakeSeconds only if it's not the user's first time staking or if there's more than one staker
    if oldStake != 0 || s.totalStakedLP[lpToken] > 0
      s.totalStakeSeconds[lpToken] -= oldStake * oldWeightedTime
      s.totalStakeSeconds[lpToken] += newStake * newWeightedTime
    end
    
    # Update staked amount for the user and the total staked LP
    s.stakedLP[user][lpToken] = newStake
    s.totalStakedLP[lpToken] = isStaking ? (s.totalStakedLP[lpToken] + amount) : (s.totalStakedLP[lpToken] - amount)
  
    # Update reward debt for the user
    s.rewardDebt[user][lpToken] = (newStake * s.accRewardsPerShare[lpToken]).div(1.ether)
    nil
  end
  
  function :swapExactTokensForTokens, { 
    amountIn: :uint256, 
    amountOutMin: :uint256, 
    path: [:address],
    to: :address, 
    deadline: :uint256 
  }, :public, :virtual, :override, returns: [:uint256] do
    amounts = UniswapV2Router.swapExactTokensForTokens(
      amountIn: amountIn - calculateFeeAmount(amountIn),
      amountOutMin: amountOutMin,
      path: path,
      to: to,
      deadline: deadline
    )
    
    feeInWETH = chargeFeeInWETH(amountIn, path[0])
    
    lpToken = pairFor(factory, path[0], path[1])
    
    updateRewards(lpToken: lpToken, feeAmount: feeInWETH)
    
    amounts
  end
  
  function :swapTokensForExactTokens, {
    amountOut: :uint256,
    amountInMax: :uint256,
    path: [:address],
    to: :address,
    deadline: :uint256
  }, :public, :virtual, :override, returns: [:uint256] do
    adjustedAmountInMax = (amountInMax * 10000 + amountInMax * feeBPS).div(10000)

    amounts = UniswapV2Router.swapTokensForExactTokens(
      amountOut: amountOut + calculateFeeAmount(amountOut),
      amountInMax: adjustedAmountInMax,
      path: path,
      to: to,
      deadline: deadline
    )
    
    feeInWETH = chargeFeeInWETH(amountOut, path[1])
    
    lpToken = pairFor(factory, path[0], path[1])
    
    updateRewards(lpToken: lpToken, feeAmount: feeInWETH)
    
    amounts
  end
  
  function :calculateFeeAmount, { amount: :uint256 }, :public, :virtual, returns: :uint256 do
    return (amount * s.feeBPS).div(10000)
  end
  
  # function :updateRewards, { lpToken: :address, feeAmount: :uint256 }, :internal do
  #   return unless s.totalStakedLP[lpToken] > 0
    
  #   currentTime = block.timestamp
  #   stakingDuration = currentTime - s.lastUpdateTime[lpToken]
    
  #   newStakeSeconds = s.totalStakedLP[lpToken] * stakingDuration
  #   s.totalStakeSeconds[lpToken] += newStakeSeconds
    
  #   s.feePool[lpToken] += feeAmount
    
  #   scalingFactor = 1.ether
  #   rewardsPerSecond = (feeAmount * scalingFactor).div(stakingDuration)
    
  #   accRewardPerShareIncrement = rewardsPerSecond.div(newStakeSeconds)
  #   s.accRewardsPerShare[lpToken] += accRewardPerShareIncrement
    
  #   s.lastUpdateTime[lpToken] = currentTime

  #   nil
  # end
  
  
  function :computeCurrentAccRewardsPerShare, { lpToken: :address }, :public, :view, returns: :uint256 do
    # Check if there are any staked LP tokens
    if s.totalStakedLP[lpToken] == 0
      return s.accRewardsPerShare[lpToken]
    end
  
    # Calculate the time since the last update
    currentTime = block.timestamp
    timeSinceLastUpdate = currentTime - s.lastUpdateTime[lpToken]
  
    # Calculate the new stake seconds
    newStakeSeconds = s.totalStakedLP[lpToken] * timeSinceLastUpdate
  
    # Calculate the total stake seconds
    totalStakeSeconds = s.totalStakeSeconds[lpToken] + newStakeSeconds
  
    # Calculate the pending rewards
    pendingRewards = s.feePool[lpToken]
  
    # Calculate the increment in accRewardsPerShare
    accRewardsPerShareIncrement = (pendingRewards * 1.ether).div(totalStakeSeconds)
  
    # Calculate the current accRewardsPerShare
    current_acc_rewards_perShare = s.accRewardsPerShare[lpToken] + accRewardsPerShareIncrement
  
    return current_acc_rewards_perShare
  end
  
  
  function :pendingRewards, { user: :address, lpToken: :address }, :public, :view, returns: :uint256 do
    # Calculate what s.accRewardsPerShare[lpToken] would be if all pending rewards were distributed
    current_acc_rewards_per_share = computeCurrentAccRewardsPerShare(lpToken)
    ::Kernel.binding.pry
    # Get user's staked LP tokens and weighted average stake time for the lpToken
    user_staked = s.stakedLP[user][lpToken]
    
    # Calculate the time since the last update
    currentTime = block.timestamp
    timeSinceLastUpdate = currentTime - s.lastUpdateTime[lpToken]
    
    # Retrieve the weighted average stake time and adjust for first-time stakers
    weighted_avg_stake_time = s.weightedAvgStakeTime[user][lpToken]
    first_stake_time = s.firstStakeTime[user][lpToken]
    time_staked = currentTime - first_stake_time

    weighted_avg_stake_time = weighted_avg_stake_time == 0 ? time_staked : weighted_avg_stake_time + timeSinceLastUpdate
    
    # Calculate user's stake-seconds
    user_stake_seconds = user_staked * weighted_avg_stake_time
    
    # Calculate pending rewards for the user based on their stake-seconds
    pending_rewards = (user_stake_seconds * current_acc_rewards_per_share).div(1.ether) - s.rewardDebt[user][lpToken]
    
    return pending_rewards
  end
  
  
  
  
  
  function :updateRewards, { lpToken: :address, feeAmount: :uint256 }, :internal do
    return unless s.totalStakedLP[lpToken] > 0
    
    # Get the current time
    currentTime = block.timestamp
    # ::Kernel.binding.pry
    # Calculate the duration since the last update
    stakingDuration = currentTime - s.lastUpdateTime[lpToken]
    
    # Update the total stake-seconds for this LP token
    s.totalStakeSeconds[lpToken] += s.totalStakedLP[lpToken] * stakingDuration
    
    # Update the accumulated rewards for the LP token
    s.feePool[lpToken] += feeAmount
    
    # Scaling to maintain precision
    scalingFactor = 1.ether
  
    # Increment in accRewardPerShare
    accRewardPerShareIncrement = (feeAmount * scalingFactor).div(
      s.totalStakedLP[lpToken] * stakingDuration
    )
    s.accRewardsPerShare[lpToken] += accRewardPerShareIncrement
    
    # Update last update time
    s.lastUpdateTime[lpToken] = currentTime
    
    nil
  end
  
  
  
  # function :updateRewards, { lpToken: :address, feeAmount: :uint256 }, :internal do
  #   return unless s.totalStakedLP[lpToken] > 0
    
  #   # Get the current time
  #   currentTime = block.timestamp
    
  #   # Calculate the duration since the last update
  #   stakingDuration = currentTime - s.lastUpdateTime[lpToken]
    
  #   # Update the total stake-seconds for this LP token
  #   s.totalStakeSeconds[lpToken] += s.totalStakedLP[lpToken] * stakingDuration
    
  #   # Update the accumulated rewards for the LP token
  #   s.feePool[lpToken] += feeAmount
  #   # ::Kernel.binding.pry
  #   scalingFactor = 1.ether  # additional scaling to maintain precision
  #   rewardsPerSecond = (feeAmount * scalingFactor).div(stakingDuration)
  #   accRewardPerShareIncrement = rewardsPerSecond.div(s.totalStakeSeconds[lpToken])
  #   s.accRewardsPerShare[lpToken] += accRewardPerShareIncrement
    
  #   # Update last update time
  #   s.lastUpdateTime[lpToken] = currentTime
    
  #   nil
  # end
  
  function :chargeFeeInWETH, {
    amount: :uint256,
    token: :address
  }, :internal, :virtual, returns: :uint256 do
    feeAmount = calculateFeeAmount(amount)
    
    if token == s.WETH
      ERC20(token).transferFrom(
        from: msg.sender,
        to: address(this),
        amount: feeAmount
      )
      
      return feeAmount
    end
    
    path = array(:address, 2)
    path[0] = token
    path[1] = s.WETH
    
    feeInWETH = UniswapV2Router.swapExactTokensForTokens(
      amountIn: feeAmount,
      amountOutMin: 0,
      path: path,
      to: address(this),
      deadline: block.timestamp + 1
    )[1]
    
    return feeInWETH
  end
end
