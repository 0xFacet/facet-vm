pragma :rubidity, "1.0.0"

import './Upgradeable.rubidity'
import './UniswapV2Router.rubidity'

contract :UniswapV2RouterWithRewards, is: [:UniswapV2Router, :Upgradeable], upgradeable: true do
  uint256 :public, :feeBPS
  
  mapping ({ address: mapping(address: :uint256) }), :public, :stakedLP
  mapping ({ address: mapping(address: :uint256) }), :public, :rewardDebt
  
  mapping ({:address => :uint256}), :public, :totalStakedLP
  mapping ({:address => :uint256}), :public, :totalStakeSeconds
  mapping ({:address => :uint256}), :public, :accRewardsPerShare
  mapping ({:address => :uint256}), :public, :lastUpdateTime
  
  mapping ({ address: mapping(address: :uint256) }), :public, :weightedAvgStakeTime
  mapping ({ address: mapping(address: :uint256) }), :public, :lastStakeTime


  constructor(
    _factory: :address,
    _WETH: :address,
    _feeBPS: :uint256,
  ) {
    require(_feeBPS <= 10000, 'Fee cannot be greater than 100%')
    
    s.feeBPS = _feeBPS
    
    UniswapV2Router.constructor(_factory: _factory, _WETH: _WETH)
    Upgradeable.constructor(upgradeAdmin: msg.sender)
  }
  
  function :stakeLP, { lpToken: :address, amount: :uint256 }, :public do
    lpPair = UniswapV2Pair(lpToken)
    token0 = lpPair.token0()
    token1 = lpPair.token1()
    
    require(token0 == s.WETH || token1 == s.WETH, 'One of the tokens must be WETH')
    
    # Call the internal function to update the staking amount
    updateStakeAmount(lpToken: lpToken, amount: amount, isStaking: true, user: msg.sender)
  
    # Transfer LP tokens from the user to this contract
    ERC20(lpToken).transferFrom(msg.sender, address(this), amount)
  end
  
  function :unstakeLP, { lpToken: :address, amount: :uint256 }, :public do
    require(s.stakedLP[msg.sender][lpToken] >= amount, 'Insufficient staked amount')
  
    # Call the internal function to update the staking amount
    updateStakeAmount(lpToken: lpToken, amount: amount, isStaking: false, user: msg.sender)
    
    # Transfer LP tokens from this contract back to the user
    ERC20(lpToken).transfer(msg.sender, amount)
  end
  
  function :withdrawRewards, { lpToken: :address }, :public do
    # Call the internal function with an amount of 0 to update and withdraw rewards
    updateStakeAmount(lpToken: lpToken, amount: 0, isStaking: true, user: msg.sender)
  end  
  
  function :updateStakeAmount, ({
    lpToken: :address,
    amount: :uint256,
    isStaking: :bool,
    user: :address }
  ), :internal do    
    # Calculate pending rewards for the user
    pending = (s.stakedLP[user][lpToken] * s.accRewardsPerShare[lpToken] / 1e12) - s.rewardDebt[user][lpToken]
    
    # Distribute pending rewards, if any
    if pending > 0
      WETH.transfer(user, pending)
    end
    
    if (pending > 0 || amount > 0)
      s.lastUpdateTime[lpToken] = block.timestamp
    end
  
    # Update user's weighted average stake-time
    oldStake = s.stakedLP[user][lpToken]
    newStake = isStaking ? (oldStake + amount) : (oldStake - amount)
    oldWeightedTime = s.weightedAvgStakeTime[user][lpToken]
    currentTime = block.timestamp
  
    newWeightedTime = ((oldStake * oldWeightedTime) + (amount * currentTime)) / newStake
  
    s.weightedAvgStakeTime[user][lpToken] = newWeightedTime
  
    s.totalStakeSeconds[lpToken] -= oldStake * oldWeightedTime
    s.totalStakeSeconds[lpToken] += newStake * newWeightedTime
  
    # Update staked amount for the user and the total staked LP
    s.stakedLP[user][lpToken] = newStake
    s.totalStakedLP[lpToken] = isStaking ? (s.totalStakedLP[lpToken] + amount) : (s.totalStakedLP[lpToken] - amount)
  
    # Update reward debt for the user
    s.rewardDebt[user][lpToken] = newStake * s.accRewardsPerShare[lpToken] / 1e12
    nil
  end
  
  function :swapExactTokensForTokens, { 
    amountIn: :uint256, 
    amountOutMin: :uint256, 
    path: [:address],
    to: :address, 
    deadline: :uint256 
  }, :public, :virtual, :override, returns: [:uint256] do
    amounts = UniswapV2Router.swapExactTokensForTokens(
      amountIn: amountIn - calculateFeeAmount(amountIn),
      amountOutMin: amountOutMin,
      path: path,
      to: to,
      deadline: deadline
    )
    
    feeInWETH = chargeFeeInWETH(amountIn, path[0])
    
    lpToken = pairFor(factory, path[0], path[1])
    
    updateRewards(lpToken: lpToken, feeAmount: feeInWETH)
    
    amounts
  end
  
  function :swapTokensForExactTokens, {
    amountOut: :uint256,
    amountInMax: :uint256,
    path: [:address],
    to: :address,
    deadline: :uint256
  }, :public, :virtual, :override, returns: [:uint256] do
    adjustedAmountInMax = (amountInMax * 10000 + amountInMax * feeBPS).div(10000)

    amounts = UniswapV2Router.swapTokensForExactTokens(
      amountOut: amountOut + calculateFeeAmount(amountOut),
      amountInMax: adjustedAmountInMax,
      path: path,
      to: to,
      deadline: deadline
    )
    
    feeInWETH = chargeFeeInWETH(amountOut, path[1])
    
    lpToken = pairFor(factory, path[0], path[1])
    
    updateRewards(lpToken: lpToken, feeAmount: feeInWETH)
    
    amounts
  end
  
  function :calculateFeeAmount, { amount: :uint256 }, :public, :virtual, returns: :uint256 do
    return (amount * s.feeBPS).div(10000)
  end
  
  function :updateRewards, { lpToken: :address, feeAmount: :uint256 }, :internal do
    if s.totalStakedLP[lpToken] > 0
      # Get the current time
      currentTime = block.timestamp
  
      # Calculate the duration of staking
      stakingDuration = currentTime - s.lastUpdateTime[lpToken]
  
      # Calculate rewards per second
      rewardsPerSecond = (feeAmount * 1.ether).div(stakingDuration)
  
      # Update accumulated rewards per share
      accRewardsPerShare[lpToken] += rewardsPerSecond.div(s.totalStakedLP[lpToken])
  
      # Update the last update time
      lastUpdateTime[lpToken] = currentTime
    end
  end
  
  # function :updateRewards, { lpToken: :address, feeAmount: :uint256 }, :internal do
  #   if totalStakedLP[lpToken] > 0
  #     # Get the current time
  #     currentTime = block.timestamp
  
  #     # Calculate the time that has passed since the last update
  #     timeElapsed = currentTime - lastUpdateTime[lpToken]
  
  #     # Update accumulated rewards per share, scaled to minimize rounding errors
  #     accRewardsPerShare[lpToken] += (feeAmount * 1e12 * timeElapsed) / totalStakedLP[lpToken]
  
  #     # Update the last update time
  #     lastUpdateTime[lpToken] = currentTime
  #   end
  # end
  
  
  function :chargeFeeInWETH, {
    amount: :uint256,
    token: :address
  }, :internal, :virtual, returns: :uint256 do
    feeAmount = calculateFeeAmount(amount)
    
    if token == s.WETH
      ERC20(token).transferFrom(
        from: msg.sender,
        to: address(this),
        amount: feeAmount
      )
      
      return feeAmount
    end
    
    path = array(:address, 2)
    path[0] = token
    path[1] = s.WETH
    
    feeInWETH = UniswapV2Router.swapExactTokensForTokens(
      amountIn: feeAmount,
      amountOutMin: 0,
      path: path,
      to: address(this),
      deadline: block.timestamp + 1
    )[1]
    
    return feeInWETH
  end
end
