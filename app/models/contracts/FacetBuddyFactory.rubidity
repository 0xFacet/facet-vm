pragma :rubidity, "1.0.0"

import "./Ownable.rubidity"
import "./FacetBuddy.rubidity"
import "./Upgradeable.rubidity"

contract :FacetBuddyFactory, is: [:Ownable, :Upgradeable], upgradeable: true do
  event :BuddyCreated, {
    forUser: :address,
    buddy: :address
  }

  address :public, :erc20Bridge
  
  mapping ({ address: :address }), :public, :buddyForUser
  mapping ({ address: :address }), :public, :userForBuddy
  
  constructor(erc20Bridge: :address) {
    require(erc20Bridge != address(0), "Invalid smart contract")

    Upgradeable.constructor(upgradeAdmin: msg.sender)
    Ownable.constructor(owner: msg.sender)

    s.erc20Bridge = erc20Bridge
  }
  
  function :findOrCreateBuddy, {
    forUser: :address
  }, :public, returns: :address do
    require(msg.sender == s.erc20Bridge, "Only erc20Bridge can create a buddy")
    
    existingBuddy = s.buddyForUser[forUser]
    
    if existingBuddy != address(0)
      return existingBridge
    end
    
    salt = keccak256(abi.encodePacked(s.erc20Bridge, forUser))
    
    buddy = new FacetBuddy(
      s.erc20Bridge,
      forUser,
      { salt: salt }
    )
    
    require(s.userForBuddy[buddy] == address(0), "Buddy already exists for user")
    
    s.buddyForUser[forUser] = buddy
    s.userForBuddy[buddy] = forUser
    
    emit :BuddyCreated, forUser: forUser, buddy: buddy
    
    return buddy
  end
end
