pragma :rubidity, "1.0.0"

import "./Upgradeable.rubidity"
import "./ERC721.rubidity"

contract :INFTCollection01, abstract: true do
  function :owner, :external, :view, returns: :address
end

contract :TokenUpgradeRenderer01, is: :Upgradeable, upgradeable: true do
  event :UpgradeLevelAdded, {
    index: :uint256,
    name: :string,
    imageURI: :string,
    animationURI: :string,
    description: :string,
    startTime: :uint256,
    endTime: :uint256,
    countAtLevel: :uint256,
    newRecord: :bool
  }
  
  event :TokenUpgraded, {
    tokenId: :uint256,
    upgradeLevel: :uint256,
    indexWithinLevel: :uint256
  }
  
  event :ContractInfoUpdated, {
    newInfo: :ContractInfo
  }
  
  struct :TokenUpgradeLevel do
    string :name
    string :imageURI
    string :animationURI
    string :description
    uint256 :startTime
    uint256 :endTime
    uint256 :countAtLevel
  end
  
  struct :TokenStatus do
    uint256 :upgradeLevel
    uint256 :indexWithinLevel
    uint256 :lastUpgradeTime
  end
  
  struct :ContractInfo do
    string :name
    string :description
    string :imageURI
    string :animationURI
  end
  
  array :TokenUpgradeLevel, :public, :tokenUpgradeLevels
  mapping ({ uint256: :TokenStatus }), :public, :tokenStatuses
  uint256 :public, :maxUpgradeLevelCount
  ContractInfo :public, :contractInfo
  
  address :public, :nftCollection

  constructor(
    nftCollection: :address,
    initialLevel: :TokenUpgradeLevel,
    contractInfo: :ContractInfo
  ) {
    Upgradeable.constructor(upgradeAdmin: msg.sender)
    
    tokenUpgradeLevels.push(newLevel)
    s.nftCollection = nftCollection
    s.maxUpgradeLevelCount = 30
    
    s.contractInfo = contractInfo
    
    requireSenderAdmin
  }
  
  function :addUpgradeLevel, { newLevel: :TokenUpgradeLevel }, :public do
    requireSenderAdmin
    lastLevel = s.tokenUpgradeLevels.last
    
    require(newLevel.startTime > lastLevel.endTime, "Start time must be after last level end time")
    require(tokenUpgradeLevels.length + 1 <= s.maxUpgradeLevelCount, "Max upgrade level count reached")

    tokenUpgradeLevels.push(newLevel)
    
    emit :UpgradeLevelUpdated,
      index: tokenUpgradeLevels.length - 1,
      name: newLevel.name,
      imageURI: newLevel.imageURI,
      animationURI: newLevel.animationURI,
      description: newLevel.description,
      startTime: newLevel.startTime,
      endTime: newLevel.endTime,
      countAtLevel: newLevel.countAtLevel,
      newRecord: true
  end
  
  function :editUpgradeLevel, { index: :uint256, newLevel: :TokenUpgradeLevel }, :public do
    requireSenderAdmin
    
    lastLevel = s.tokenUpgradeLevels.last
    require(newLevel.startTime > lastLevel.endTime, "Start time must be after last level end time")
        
    s.tokenUpgradeLevels[index] = newLevel
    
    emit :UpgradeLevelUpdated,
      index: index,
      name: newLevel.name,
      imageURI: newLevel.imageURI,
      animationURI: newLevel.animationURI,
      description: newLevel.description,
      startTime: newLevel.startTime,
      endTime: newLevel.endTime,
      countAtLevel: newLevel.countAtLevel,
      newRecord: false
  end
  
  function :activeUpgradeLevel, :public, :view, returns: { level: :TokenUpgradeLevel, index: :uint256 } do
    forLoop(
      condition: -> i { i < tokenUpgradeLevels.length }
    ) do |i|
      level = tokenUpgradeLevels[i]
      if level.startTime < block.timestamp && level.endTime > block.timestamp
        return { level: level, index: i }
      end
    end
    
    return { level: TokenUpgradeLevel(), index: 0 }
  end
  
  function :upgradeToken, { tokenId: :uint256 }, :public do
    require(
      isApprovedOrOwner(spender: msg.sender, id: tokenId),
      "TokenUpgradeRenderer: msg.sender not authorized to upgrade id #{tokenId.toString}"
    );
    
    tokenStatus = tokenStatuses[tokenId]
    activeUpgrade, activeUpgradeIndex = activeUpgradeLevel()
    
    require(activeUpgradeIndex > 0, "TokenUpgradeRenderer: No active upgrade level")
    require(tokenStatus.lastUpgradeTime < activeUpgrade.startTime, "TokenUpgradeRenderer: Token already upgraded at this level")
    
    targetLevelIndex = tokenStatus.upgradeLevel + 1
    targetLevel = tokenUpgradeLevels[targetLevelIndex]
    
    targetLevel.countAtLevel += 1
    
    tokenStatus.upgradeLevel = targetLevelIndex
    tokenStatus.lastUpgradeTime = block.timestamp
    tokenStatus.indexWithinLevel = targetLevel.countAtLevel
    
    emit :TokenUpgraded,
      tokenId: tokenId,
      upgradeLevel: tokenStatus.upgradeLevel,
      indexWithinLevel: tokenStatus.indexWithinLevel
  end

  function :setContractInfo, { info: :ContractInfo }, :public do
    requireSenderAdmin
    
    s.contractInfo = info
    emit :ContractInfoUpdated, newInfo: info
  end

  function :tokenURI, { tokenId: :uint256 }, :external, :view, returns: :string do
    status = s.tokenStatuses[tokenId]
    upgradeLevel = s.tokenUpgradeLevels[status.upgradeLevel]
    
    index = if status.upgradeLevel == 0
      tokenId
    else
      status.indexWithinLevel
    end
    
    attributes = [
      {
        "display_type": "number",
        "trait_type": "Number",
        "value": index
      },
      {
        "trait_type": "Upgrade Level",
        "value": upgradeLevel.name
      }
    ]
    
    json_data = json.stringify(
      name: "#{upgradeLevel.name} #{index.toString}",
      description: upgradeLevel.description,
      image: upgradeLevel.imageURI,
      animation_url: upgradeLevel.animationURI,
      attributes: attributes
    )
    
    "data:application/json;base64," + json_data.base64Encode
  end
  
  function :contractURI, :external, :view, returns: :string do
    json_data = json.stringify(
      name: s.contractInfo.name,
      description: s.contractInfo.description,
      image: s.contractInfo.imageURI,
      animation_url: s.contractInfo.animationURI
    )
    
    "data:application/json;base64," + json_data.base64Encode
  end
  
  function :requireSenderAdmin, :internal, :view do
    require(s.nftContract == msg.sender || INFTCollection01(s.nftContract).owner() == msg.sender, "Admin access only")
  end
end
