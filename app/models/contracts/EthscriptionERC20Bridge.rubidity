pragma :rubidity, "1.0.0"

import './ERC20.rubidity'

contract :EthscriptionERC20Bridge, is: :ERC20 do
  event :InitiateWithdrawal, { from: :address, amount: :uint256 }
  event :WithdrawalComplete, { to: :address, amount: :uint256 }
  event :BridgedIn, { to: :address, amount: :uint256 }
  
  address :public, :trustedSmartContract
  mapping ({ address: :uint256 }), :public, :bridgedInAmounts
  mapping ({ address: :uint256 }), :public, :pendingWithdrawalAmounts
  
  constructor(
    name: :string,
    symbol: :string,
    trustedSmartContract: :address,
  ) {
    ERC20.constructor(name: name, symbol: symbol, decimals: 18)
    
    s.trustedSmartContract = trustedSmartContract
  }
  
  function :bridgeIn, { to: :address, amount: :uint256 }, :public do
    require(
      msg.sender == s.trustedSmartContract,
      "Only the trusted smart contract can bridge in tokens"
    )
    
    s.bridgedInAmounts[to] += amount

    _mint(to: to, amount: amount)
    emit :BridgedIn, to: to, amount: amount
  end
  
  function :bridgeOut, { amount: :uint256 }, :public do
    require(
      s.bridgedInAmounts[msg.sender] >= amount,
      "Not enough bridged in"
    )

    s.bridgedInAmounts[msg.sender] -= amount
    s.pendingWithdrawalAmounts[msg.sender] += amount
      
    _burn(from: msg.sender, amount: amount)
    emit :InitiateWithdrawal, from: msg.sender, amount: amount
  end
  
  function :markWithdrawalComplete, {
    to: :address,
    amount: :uint256
  }, :public do
    require(
      msg.sender == s.trustedSmartContract,
      'Only the trusted smart contract can mark withdrawals as complete'
    )
    require(
      s.pendingWithdrawalAmounts[to] >= amount,
      "Not enough pending withdrawal"
    )

    s.pendingWithdrawalAmounts[to] -= amount

    emit :WithdrawalComplete, to: to, amount: amount
  end
end
