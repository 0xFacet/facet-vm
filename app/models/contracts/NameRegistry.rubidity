pragma :rubidity, "1.0.0"

import './Upgradeable.rubidity'
import './ERC721.rubidity'
import './ERC20.rubidity'
import './NameRegistryRenderer.rubidity'

contract :NameRegistry, is: [:ERC721, :Upgradeable, :NameRegistryRenderer], upgradeable: true do
  # TODO: events
  # TODO: broader pause functionality
  
  event :NameRegistered, { tokenId: :uint256, owner: :address, name: :string, expires: :uint256 }
  event :NameRenewed, { tokenId: :uint256, newExpiry: :uint256 }
  event :PrimaryNameSet, { user: :address, tokenId: :uint256 }
  event :RegistrationPaused, { newState: :bool }
  event :ConversionRateUpdate, { newRate: :uint256 }

  address :public, :WETH
  address :public, :admin
  address :public, :trustedSmartContract
  uint256 :public, :usdWeiCentsInOneEth
  uint256 :public, :minRegistrationDuration
  uint256 :public, :gracePeriod
  uint256 :public, :maxNameLength
  
  string :public, :description
  
  array :uint256, :public, :charCountToUsdWeiCentsPrice, initial_length: 0
  
  bool :public, :registrationPaused
  
  uint256 :public, :nextTokenId
  mapping ({ string: :uint256 }), :public, :nameToTokenId
  mapping ({ uint256: :string }), :public, :tokenIdToName
  mapping ({ address: :uint256 }), :internal, :userToPrimaryNameTokenId
  
  mapping ({ uint256: :uint256 }), :public, :tokenExpiryTimes
  
  mapping ({ address: :string }), :public, :userDisplayNames
  mapping ({ address: :string }), :public, :userBios
  mapping ({ address: :string }), :public, :userImageURIs
  mapping ({ address: [:string] }), :public, :userLinks
  
  uint256 :public, :maxStickerId
  uint256 :public, :nextStickerId
  mapping ({ uint256: :string }), :public, :stickerIdToName
  mapping ({ uint256: :string }), :public, :stickerIdToImageURI
  
  mapping ({ uint256: [:uint256] }), :public, :tokenIdToStickerIdsAry
  mapping ({ uint256: mapping(uint256: :bool) }), :public, :tokenIdToStickerIdsAwardedMap
  mapping ({ uint256: mapping(uint256: array(:uint256, 3)) }), :public, :tokenIdToStickerPosition
  
  function :createSticker, {
    name: :string,
    imageURI: :string
  }, :public do
    require(msg.sender == s.admin, 'Only the admin can create stickers')
    require(name.length > 0, 'Name must be non-empty')
    require(s.stickerId <= s.maxStickerId, 'Sticker ID overflow')

    # TODO: enforce name uniqueness?
    s.stickerIdToName[s.nextStickerId] = name
    s.stickerIdToImageURI[s.nextStickerId] = imageURI
    
    s.nextStickerId += 1
    nil
  end
  
  function :awardSticker, {
    stickerId: :uint256,
    tokenId: :uint256,
    position: array(:uint256, 3)
  }, :public do
    require(msg.sender == s.admin, "Only the admin can award stickers")
    require(!s.tokenIdToStickerIdsAwardedMap[tokenId][stickerId], "Sticker already awarded")
    
    s.tokenIdToStickerIdsAwardedMap[tokenId][stickerId] = true
    s.tokenIdToStickerPosition[tokenId][stickerId] = position
    s.tokenIdToStickerIdsAry[tokenId].push(stickerId)
    
    nil
  end
  
  constructor(
    name: :string,
    symbol: :string,
    trustedSmartContract: :address,
    admin: :address,
    usdWeiCentsInOneEth: :uint256,
    charCountToUsdWeiCentsPrice: [:uint256],
    cardTemplate: :string,
    _WETH: :address
  ) {
    require(charCountToUsdWeiCentsPrice.length >= 4, 'Must have at least 4 price points')
    require(charCountToUsdWeiCentsPrice.length <= 10, 'Must have at most 10 price points')

    ERC721.constructor(name: name, symbol: symbol)
    Upgradeable.constructor(upgradeAdmin: msg.sender)
    NameRegistryRenderer.constructor(cardTemplate: cardTemplate)
    
    s.admin = admin
    s.trustedSmartContract = trustedSmartContract
    s.WETH = _WETH
    s.usdWeiCentsInOneEth = usdWeiCentsInOneEth
    
    s.charCountToUsdWeiCentsPrice = charCountToUsdWeiCentsPrice
    
    s.maxNameLength = 32
    s.gracePeriod = 90.days
    s.minRegistrationDuration = 28.days
    s.nextTokenId = 1
    s.nextStickerId = 1
    s.registrationPaused = true
    s.maxStickerId = 25
  }
  
  function :registerNameWithPayment, { to: :address, name: :string, durationInSeconds: :uint256 }, :public, returns: :bool do
    require(!s.registrationPaused, 'Registration paused')
    require(durationInSeconds >= s.minRegistrationDuration, 'Duration too short')
    
    _registerName(to: to, name: name, durationInSeconds: durationInSeconds)
    
    if to == msg.sender && s.userToPrimaryNameTokenId[msg.sender] == 0
      tokenId = s.nameToTokenId[name]
      s.userToPrimaryNameTokenId[msg.sender] = tokenId
    end
    
    ERC20(s.WETH).transferFrom(
      msg.sender,
      address(this),
      getPrice(name, durationInSeconds)
    )
  end
  
  function :renewNameWithPayment, { name: :string, durationInSeconds: :uint256 }, :public, returns: :bool do
    _renewName(name: name, durationInSeconds: durationInSeconds)
    
    ERC20(s.WETH).transferFrom(
      msg.sender,
      address(this),
      getPrice(name, durationInSeconds)
    )
  end
  
  function :_registerName, { to: :address, name: :string, durationInSeconds: :uint256 }, :internal do
    require(nameAvailable(name), 'Name not available')
    require(nameIsValid(name), 'Invalid name')
    
    tokenId = s.nameToTokenId[name]
    
    if _exists(tokenId)
      # Name expired, burn it
      _burn(tokenId)
    else
      tokenId = s.nextTokenId
      s.nextTokenId += 1
    end
    
    _mint(to: to, id: tokenId)
    
    s.nameToTokenId[name] = tokenId
    s.tokenIdToName[tokenId] = name
    
    s.tokenExpiryTimes[tokenId] = block.timestamp + durationInSeconds
    
    emit :NameRegistered, tokenId: tokenId, owner: to, name: name, expires: s.tokenExpiryTimes[tokenId]
  end
  
  function :_renewName, { name: :string, durationInSeconds: :uint256 }, :internal do
    tokenId = s.nameToTokenId[name]
    
    currentExpiry = s.tokenExpiryTimes[tokenId]
    
    require(currentExpiry + s.gracePeriod >= block.timestamp, 'Must be registered or in grace period')
    
    s.tokenExpiryTimes[tokenId] = currentExpiry + durationInSeconds

    emit :NameRenewed, tokenId: tokenId, newExpiry: s.tokenExpiryTimes[tokenId]
  end
  
  function :importFromPreregistration, { names: [:string], owners: [:address], durations: [:uint256] }, :public do
    require(msg.sender == s.trustedSmartContract, 'Only the trusted smart contract can import names')
    require(names.length == owners.length, 'Names and owners must be the same length')
    require(names.length == durations.length, 'Names and owners must be the same length')
    require(names.length <= 10, 'Cannot import more than 10 names at a time')
    
    forLoop(
      start: 0,
      step: 1,
      condition: -> i { i < names.length }
    ) do |i|
      _registerName(to: owners[i], name: names[i], durationInSeconds: durations[i])
    end
  end
  
  function :tokenURI, { id: :uint256 }, :public, :view, :override, returns: :string do
    require(_exists(id: id), 'ERC721Metadata: URI query for nonexistent token')
    
    name = s.tokenIdToName[id]
    owner = ownerOf(id)

    card = NameRegistryRenderer.renderCard(id, name)
    b64Card = "data:text/html;charset=utf-8;base64," + esc.base64Encode(card)
    
    json_data = esc.jsonEncode(
      name: "#{name} (##{id.toString})",
      description: s.userBios[owner],
      image: b64Card,
    )
    
    return "data:application/json,#{json_data}"
  end
  
  function :setUserDetails, {
    realName: :string,
    bio: :string,
    imageURI: :string,
    links: [:string]
  }, :public do
    s.userDisplayNames[msg.sender] = realName
    s.userBios[msg.sender] = bio
    s.userImageURIs[msg.sender] = imageURI
    s.userLinks[msg.sender] = links
    nil
  end
  
  function :getUserDetails, { user: :address }, :public, :view, returns: {
    realName: :string,
    bio: :string,
    imageURI: :string,
    links: [:string]
  } do
    return {
      realName: s.userDisplayNames[user],
      bio: s.userBios[user],
      imageURI: s.userImageURIs[user],
      links: s.userLinks[user]
    }
  end
  
  function :_burn, { id: :uint256 }, :internal, :override do
    owner = s._ownerOf[id];
    
    if s.userToPrimaryNameTokenId[owner] == id
      s.userToPrimaryNameTokenId[owner] = 0
    end
    
    ERC721._burn(id)
  end
  
  function :transferFrom, { from: :address, to: :address, id: :uint256 }, :public, :override do
    if s.userToPrimaryNameTokenId[from] == id
      s.userToPrimaryNameTokenId[from] = 0
    end
    
    ERC721.transferFrom(from: from, to: to, id: id)
  end
  
  function :ownerOf, { id: :uint256 }, :public, :view, :override, returns: :address do
    owner = ERC721.ownerOf(id)
    require(s.tokenExpiryTimes[id] > block.timestamp, 'Name expired')
    owner
  end
  
  function :lookupAddress, { user: :address }, :public, :view, returns: :string do
    candidateId = s.userToPrimaryNameTokenId[user]
    require(ownerOf(candidateId) == user, 'Not the owner')

    s.tokenIdToName[candidateId]
  end
  
  function :setPrimaryName, { name: :string }, :public do
    tokenId = s.nameToTokenId[name]
    require(msg.sender == ownerOf(tokenId), 'Not the owner')
    s.userToPrimaryNameTokenId[msg.sender] = tokenId
    
    emit :PrimaryNameSet, user: msg.sender, tokenId: tokenId
  end
  
  function :resolveName, { name: :string }, :public, :view, returns: :address do
    tokenId = s.nameToTokenId[name]
    ownerOf(tokenId)
  end
  
  function :nameIsValid, { name: :string }, :public, :view, returns: :bool do
    name.length <= s.maxNameLength &&
    esc.strIsAlphaNumeric(name) &&
    name.downcase == name
  end
  
  function :nameAvailable, { name: :string }, :public, :view, returns: :bool do
    tokenId = s.nameToTokenId[name]
    
    s.tokenExpiryTimes[tokenId] + s.gracePeriod < block.timestamp
  end
  
  function :getPrice, { name: :string, durationInSeconds: :uint256 }, :public, :view, returns: :uint256 do
    len = name.length
  
    priceWeiCentsPerSecond = if len >= s.charCountToUsdWeiCentsPrice.length
      s.charCountToUsdWeiCentsPrice.last
    else
      s.charCountToUsdWeiCentsPrice[len - 1]
    end
  
    totalPriceWeiCents = priceWeiCentsPerSecond * durationInSeconds
  
    (totalPriceWeiCents * 1.ether).div(s.usdWeiCentsInOneEth)
  end
  
  function :updateRegistrationPaused, { newState: :bool }, :public do
    require(msg.sender == s.admin, 'Only the admin can pause registration')
    s.registrationPaused = newState
    
    emit :RegistrationPaused, newState: newState
  end
  
  function :setusdWeiCentsInOneEth, { rate: :uint256 }, :public do
    require(msg.sender == s.admin, 'Only the admin can set the ETH to USD rate')
    s.usdWeiCentsInOneEth = rate
    
    emit :ConversionRateUpdate, newRate: rate
  end
  
  function :withdrawWETH, :public, returns: :bool do
    require(msg.sender == s.admin, 'Only the admin can withdraw WETH')
    
    amount = ERC20(s.WETH).balanceOf(address(this))
    ERC20(s.WETH).transfer(msg.sender, amount)
  end
  
  function :totalSupply, :public, :view, returns: :uint256 do
    nextTokenId - 1
  end
end
