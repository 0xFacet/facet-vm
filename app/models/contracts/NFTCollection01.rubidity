pragma :rubidity, "1.0.0"

import "./EditionMetadataRenderer01.rubidity"
import "./Ownable.rubidity"
import "./Pausable.rubidity"
import "./Upgradeable.rubidity"
import "./ERC2981.rubidity"
import "./ERC721.rubidity"
import "./ERC20.rubidity"
import "./MerkleProof.rubidity"

contract :NFTCollection01, is: [:ERC721, :ERC2981, :Upgradeable, :Ownable, :Pausable, :MerkleProof], upgradeable: true do
  event :Minted, { to: :address, amount: :uint256, isPublic: :bool }
  event :PublicMaxPerAddressUpdated, { publicMaxPerAddress: :uint256 }
  event :PublicMintStartUpdated, { publicMintStart: :uint256 }
  event :PublicMintEndUpdated, { publicMintEnd: :uint256 }
  event :PublicMintPriceUpdated, { publicMintPrice: :uint256 }
  event :AllowListMerkleRootUpdated, { allowListMerkleRoot: :bytes32 }
  event :AllowListMaxPerAddressUpdated, { allowListMaxPerAddress: :uint256 }
  event :AllowListMintStartUpdated, { allowListMintStart: :uint256 }
  event :AllowListMintEndUpdated, { allowListMintEnd: :uint256 }
  event :AllowListMintPriceUpdated, { allowListMintPrice: :uint256 }
  event :MaxSupplyUpdated, { maxSupply: :uint256 }
  event :BaseURIUpdated, { baseURI: :string }
  event :MetadataRendererUpdated, { metadataRenderer: :string }

  uint256 :public, :maxSupply
  uint256 :public, :totalSupply
  uint256 :public, :maxPerMint
  string :public, :baseURI
  address :public, :WETH
  address :public, :metadataRenderer

  uint256 :public, :publicMaxPerAddress
  uint256 :public, :publicMintStart
  uint256 :public, :publicMintEnd
  uint256 :public, :publicMintPrice

  bytes32 :public, :allowListMerkleRoot
  uint256 :public, :allowListMaxPerAddress
  uint256 :public, :allowListMintStart
  uint256 :public, :allowListMintEnd
  uint256 :public, :allowListMintPrice

  mapping ({ address: :uint256 }), :internal, :_publicMintCount
  mapping ({ address: :uint256 }), :internal, :_allowListMintCount
  
  constructor(
    name: :string,
    symbol: :string,
    owner: :address,
    maxSupply: :uint256,
    baseURI: :string,
    weth: :address
  ) {
    ERC721.constructor(name: name, symbol: symbol)
    Ownable.constructor(owner: owner)
    Upgradeable.constructor(upgradeAdmin: msg.sender)
    s.maxSupply = maxSupply
    s.baseURI = baseURI
    s.WETH = weth
    s.maxPerMint = 25
  }

  function :_handleMint, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :internal do
    whenNotPaused!

    require(isMintActive(), "Mint is not active")
    require(amount > 0, "Amount must be positive")
    require(s.maxSupply == 0 || s.totalSupply + amount <= s.maxSupply, "Exceeded max supply")

    isAllowListMint = merkleProof.length > 0 && isAllowListMintActive()
    mintCount = 0
    mintPrice = s.publicMintPrice
    maxPerAddress = s.publicMaxPerAddress
    if isAllowListMint
      require(isOnAllowList(to, merkleProof), "Not on allow list")
      s._allowListMintCount[to] += amount
      mintCount = s._allowListMintCount[to]
      maxPerAddress = s.allowListMaxPerAddress
      mintPrice = s.allowListMintPrice
    else
      s._publicMintCount[to] += amount
      mintCount = s._publicMintCount[to]
    end
    require(maxPerAddress == 0 || mintCount <= maxPerAddress, "Exceeded mint limit")

    if s.WETH != address(0) && mintPrice > 0
      ERC20(s.WETH).transferFrom(
        msg.sender,
        address(this),
        mintPrice
      )
    end
    
    initialId = s.totalSupply + 1

    forLoop(
      condition: -> i { i < amount },
      max_iterations: s.maxPerMint
    ) do |i|
      _mint(to: to, id: initialId + i)
    end

    emit :Minted, to: to, amount: amount, isPublic: !isAllowListMint
  end

  function :isPublicMintActive, :public, :view, returns: :bool do
    isNotMintedOut = s.maxSupply == 0 || s.totalSupply < s.maxSupply
    isOwner = s.owner == msg.sender
    isOrAfterStart = block.timestamp >= s.publicMintStart && s.publicMintStart > 0
    isBeforeEnd = block.timestamp < s.publicMintEnd || s.publicMintEnd == 0
    isWithinWindow = isOrAfterStart && isBeforeEnd
    
    isNotMintedOut && (isOwner || isWithinWindow)
  end

  function :isAllowListMintActive, :public, :view, returns: :bool do
    isNotMintedOut = s.maxSupply == 0 || s.totalSupply < s.maxSupply
    isOwner = s.owner == msg.sender
    isOrAfterStart = block.timestamp >= s.allowListMintStart && s.allowListMintStart > 0
    isBeforeEnd = block.timestamp < s.allowListMintEnd || s.allowListMintEnd == 0
    isWithinWindow = isOrAfterStart && isBeforeEnd
    
    isNotMintedOut && (isOwner || isWithinWindow)
  end

  function :isMintActive, :public, :view, returns: :bool do
    isPublicMintActive() || isAllowListMintActive()
  end

  function :isOnAllowList, { wallet: :address, merkleProof: [:bytes32] }, :public, :view, returns: :bool do
    MerkleProof.verify(
      merkleProof,
      s.allowListMerkleRoot,
      keccak256(abi.encodePacked(wallet))
    )
  end

  function :tokenURI, { tokenId: :uint256 }, :public, :view, :override, returns: :string do
    require(_exists(id: tokenId), "URI query for nonexistent token")

    if s.metadataRenderer != address(0)
      return EditionMetadataRenderer01(metadataRenderer).tokenURI(tokenId)
    end

    if s.baseURI.length == 0
      return ""
    end

    if s.baseURI[s.baseURI.length - 1] != "/"
      return s.baseURI
    end

    s.baseURI + tokenId.toString()
  end

  function :airdrop, { to: :address, amount: :uint256, merkleProof: [:bytes32] }, :public do
    _handleMint(to: to, amount: amount, merkleProof: merkleProof)
  end

  function :mint, { amount: :uint256, merkleProof: [:bytes32] }, :public do
    _handleMint(to: msg.sender, amount: amount, merkleProof: merkleProof)
  end

  function :setPublicMaxPerAddress, { publicMaxPerAddress: :uint256 }, :public do
    onlyOwner!

    s.publicMaxPerAddress = publicMaxPerAddress
    emit :PublicMaxPerAddressUpdated, publicMaxPerAddress: publicMaxPerAddress
  end

  function :setPublicMintStart, { publicMintStart: :uint256 }, :public do
    onlyOwner!

    s.publicMintStart = publicMintStart
    emit :PublicMintStartUpdated, publicMintStart: publicMintStart
  end

  function :setPublicMintEnd, { publicMintEnd: :uint256 }, :public do
    onlyOwner!

    s.publicMintEnd = publicMintEnd
    emit :PublicMintEndUpdated, publicMintEnd: publicMintEnd
  end

  function :setPublicMintPrice, { publicMintPrice: :uint256 }, :public do
    onlyOwner!

    s.publicMintPrice = publicMintPrice
    emit :PublicMintPriceUpdated, publicMintPrice: publicMintPrice
  end

  function :setAllowListMerkleRoot, { allowListMerkleRoot: :bytes32 }, :public do
    onlyOwner!

    s.allowListMerkleRoot = allowListMerkleRoot
    emit :AllowListMerkleRootUpdated, allowListMerkleRoot: allowListMerkleRoot
  end

  function :setAllowListMaxPerAddress, { allowListMaxPerAddress: :uint256 }, :public do
    onlyOwner!

    s.allowListMaxPerAddress = allowListMaxPerAddress
    emit :AllowListMaxPerAddressUpdated, allowListMaxPerAddress: allowListMaxPerAddress
  end

  function :setAllowListMintStart, { allowListMintStart: :uint256 }, :public do
    onlyOwner!

    s.allowListMintStart = allowListMintStart
    emit :AllowListMintStartUpdated, allowListMintStart: allowListMintStart
  end

  function :setAllowListMintEnd, { allowListMintEnd: :uint256 }, :public do
    onlyOwner!

    s.allowListMintEnd = allowListMintEnd
    emit :AllowListMintEndUpdated, allowListMintEnd: allowListMintEnd
  end

  function :setAllowListMintPrice, { allowListMintPrice: :uint256 }, :public do
    onlyOwner!

    s.allowListMintPrice = allowListMintPrice
    emit :AllowListMintPriceUpdated, allowListMintPrice: allowListMintPrice
  end

  function :setMaxSupply, { maxSupply: :uint256 }, :public do
    onlyOwner!

    require(s.maxSupply == 0, "Max supply already set")

    s.maxSupply = maxSupply
    emit :MaxSupplyUpdated, maxSupply: maxSupply
  end

  function :setMetadataRenderer, { metadataRenderer: :address }, :public do
    onlyOwner!

    s.metadataRenderer = metadataRenderer
    emit :MetadataRendererUpdated, metadataRenderer: metadataRenderer
  end

  function :setPublicMintSettings, {
    publicMaxPerAddress: :uint256,
    publicMintStart: :uint256,
    publicMintEnd: :uint256,
    publicMintPrice: :uint256
  }, :public do
    setPublicMaxPerAddress(publicMaxPerAddress)
    setPublicMintStart(publicMintStart)
    setPublicMintEnd(publicMintEnd)
    setPublicMintPrice(publicMintPrice)
  end

  function :setAllowListMintSettings, {
    allowListMerkleRoot: :bytes32,
    allowListMaxPerAddress: :uint256,
    allowListMintStart: :uint256,
    allowListMintEnd: :uint256,
    allowListMintPrice: :uint256
  }, :public do
    setAllowListMerkleRoot(allowListMerkleRoot)
    setAllowListMaxPerAddress(allowListMaxPerAddress)
    setAllowListMintStart(allowListMintStart)
    setAllowListMintEnd(allowListMintEnd)
    setAllowListMintPrice(allowListMintPrice)
  end

  function :setBaseURI, { baseURI: :string }, :public do
    onlyOwner!

    s.baseURI = baseURI
    emit :BaseURIUpdated, baseURI: baseURI
  end

  function :pause, :public do
    onlyOwner!
    
    _pause()
  end

  function :unpause, :public do
    onlyOwner!
    
    _unpause()
  end

  function :withdrawWETH, :public, returns: :bool do
    onlyOwner!
    
    amount = ERC20(s.WETH).balanceOf(address(this))
    ERC20(s.WETH).transfer(s.owner, amount)
  end

  function :setDefaultRoyalty, { receiver: :address, feeNumerator: :uint96 }, :public do
    onlyOwner!
    
    _setDefaultRoyalty(receiver: receiver, feeNumerator: feeNumerator)
  end

  function :deleteDefaultRoyalty, :public do
    onlyOwner!
    
    _deleteDefaultRoyalty()
  end

  function :setTokenRoyalty, { tokenId: :uint256, receiver: :address, feeNumerator: :uint96 }, :public do
    onlyOwner!
    
    _setTokenRoyalty(tokenId: tokenId, receiver: receiver, feeNumerator: feeNumerator)
  end

  function :deleteTokenRoyalty, { tokenId: :uint256 }, :public do
    onlyOwner!
    
    _deleteTokenRoyalty(tokenId)
  end
end
