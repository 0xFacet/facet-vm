pragma :rubidity, "1.0.0"

import './Ownable.rubidity'
import './Pausable.rubidity'
import './Upgradeable.rubidity'
import './ERC2981.rubidity'
import './ERC721.rubidity'
import './ERC20.rubidity'

contract :FacetPortV1, is: [:Upgradeable, :Ownable, :Pausable], upgradeable: true do
  event :AssetPurchased, {
    seller: :address,
    buyer: :address,
    assetContract: :address,
    assetId: :uint256,
    price: :uint256,
    currency: :address,
    listingId: :bytes32
  }
  
  event :BidAccepted, {
    bidder: :address,
    seller: :address,
    assetContract: :address,
    assetId: :uint256,
    bidAmount: :uint256,
    currency: :address,
  }
  
  event :BidCancelled, {
    bidder: :address,
    bidId: :bytes32
  }
  
  event :AllBidsOnAssetCancelledForUser, {
    bidder: :address,
    assetContract: :address,
    assetId: :uint256
  }
  
  event :AllBidsCancelledForUser, {
    bidder: :address
  }
  
  event :MultiplePurchaseResult, {
    buyer: :address,
    successfulListingIds: [:bytes32],
    failedListingIds: [:bytes32]
  }
  
  event :MultipleBidResult, {
    seller: :address,
    successfulBidIds: [:bytes32],
    failedBidIds: [:bytes32]
  }
  
  event :ListingCancelled, {
    seller: :address,
    listingId: :bytes32
  }
  
  event :AllListingsOfAssetCancelledForUser, {
    seller: :address,
    assetContract: :address,
    assetId: :uint256
  }
  
  event :AllListingsCancelledForUser, {
    seller: :address
  }
  
  mapping ({ address: mapping(bytes32: :bool) }), :public, :userListingCancellations
  mapping ({ address: mapping(address: mapping(uint256: :uint256)) }),
    :public,
    :userListingsOfAssetValidAfterTime
  mapping ({ address: :uint256 }), :public, :userListingsValidAfterTime
  
  mapping ({ address: mapping(bytes32: :bool) }), :public, :bidCancellations
  mapping ({ address: mapping(address: mapping(uint256: :uint256)) }),
    :public,
    :userBidsOnAssetValidAfterTime
  mapping ({ address: :uint256 }), :public, :userBidsValidAfterTime
  
  uint96 :feeBps
  
  constructor(_feeBps: :uint96) {
    s.feeBps = _feeBps
    
    Upgradeable.constructor(upgradeAdmin: msg.sender)
    Ownable.constructor(owner: msg.sender)
    # Pausable.constructor(initialPauseState: true)
  }
  
  function :setFeeBps, { _feeBps: :uint96 }, :external do
    onlyOwner!
    s.feeBps = _feeBps
  end
  
  function :buyMultipleWithSignatures, { 
    listingIds: [:bytes32],
    sellers: [:address],
    assetContracts: [:address],
    assetIds: [:uint256],
    currencies: [:address],
    prices: [:uint256],
    startTimes: [:uint256],
    endTimes: [:uint256],
    signatures: [:bytes]
  }, :external do
    require(listingIds.length == sellers.length, "Listing ID and seller arrays must be the same length")
    require(listingIds.length <= 20, "Cannot buy more than 20 listings at a time")
    
    successfulListingIds = array(:bytes32)
    failedListingIds = array(:bytes32)
    
    forLoop(
      condition: -> i { i < listingIds.length }
    ) do |i|
      success = _buyWithSignature(
        buyer: msg.sender,
        listingId: listingIds[i],
        seller: sellers[i],
        assetContract: assetContracts[i],
        assetId: assetIds[i],
        currency: currencies[i],
        price: prices[i],
        startTime: startTimes[i],
        endTime: endTimes[i],
        signature: signatures[i]
      )
      
      if success
        successfulListingIds.push(listingIds[i])
      else
        failedListingIds.push(listingIds[i])
      end
    end
    
    require(successfulListingIds.length > 0, "No bids were successfully accepted")

    emit :MultiplePurchaseResult,
      buyer: msg.sender,
      successfulListingIds: successfulListingIds,
      failedListingIds: failedListingIds
  end
  
  function :buyWithSignature, {
    listingId: :bytes32,
    seller: :address,
    assetContract: :address,
    assetId: :uint256,
    currency: :address,
    price: :uint256,
    startTime: :uint256,
    endTime: :uint256,
    signature: :bytes
  }, :public do
    success = _buyWithSignature(
      buyer: msg.sender,
      listingId: listingId,
      seller: seller,
      assetContract: assetContract,
      assetId: assetId,
      currency: currency,
      price: price,
      startTime: startTime,
      endTime: endTime,
      signature: signature
    )
    
    require(success, "Seller no longer owns NFT")
    
    emit :AssetPurchased,
      seller: seller,
      buyer: msg.sender,
      assetContract: assetContract,
      assetId: assetId,
      price: price,
      currency: currency,
      listingId: listingId
  end
  
  function :_buyWithSignature, {
    buyer: :address,
    listingId: :bytes32,
    seller: :address,
    assetContract: :address,
    assetId: :uint256,
    currency: :address,
    price: :uint256,
    startTime: :uint256,
    endTime: :uint256,
    signature: :bytes
  }, :internal, returns: :bool do
    whenNotPaused!
    
    signatureValid = signature.verifyTypedDataSignature(
      {Listing: [
        { name: "listingId", type: "bytes32" },
        { name: "seller", type: "address" },
        { name: "assetContract", type: "address" },
        { name: "assetId", type: "uint256" },
        { name: "currency", type: "address" },
        { name: "price", type: "uint256" },
        { name: "startTime", type: "uint256" },
        { name: "endTime", type: "uint256" }
      ]},
      {
        listingId: listingId,
        seller: seller,
        assetContract: assetContract,
        assetId: assetId,
        currency: currency,
        price: price,
        startTime: startTime,
        endTime: endTime
      },
      verifyingContract: address(this),
      domainName: "FacetPort",
      domainVersion: "1",
      signer: seller
    )
    
    require(signatureValid, "Invalid signature")
    
    require(block.timestamp >= startTime, "Current time is before the start time")
    require(block.timestamp <= endTime, "Current time is after the end time")
    require(!s.userListingCancellations[seller][listingId], "Listing has been cancelled by the user")
    require(startTime > s.userListingsOfAssetValidAfterTime[seller][assetContract][assetId],
      "Start time is before the valid after time for the user's listing")
    require(startTime > s.userListingsValidAfterTime[seller],
      "Start time is before the valid after time for the user's listing")
    
    s.userListingCancellations[seller][listingId] = true
    
    return payRoyaltiesAndTransfer(
      assetContract: assetContract,
      assetId: assetId,
      seller: seller,
      buyer: msg.sender,
      price: price,
      currency: currency
    )
  end
  
  function :acceptMultipleBidsWithSignatures, { 
    bidIds: [:bytes32],
    bidders: [:address],
    assetContracts: [:address],
    assetIds: [:uint256],
    currencies: [:address],
    bidAmounts: [:uint256],
    startTimes: [:uint256],
    endTimes: [:uint256],
    signatures: [:bytes]
  }, :external do
    require(bidIds.length == bidders.length, "Bid ID and bidder arrays must be the same length")
    require(bidIds.length <= 20, "Cannot accept more than 20 bids at a time")
    
    successfulBidIds = array(:bytes32)
    failedBidIds = array(:bytes32)
    
    forLoop(
      condition: -> i { i < bidIds.length }
    ) do |i|
      success = _acceptBidWithSignature(
        seller: msg.sender,
        bidId: bidIds[i],
        bidder: bidders[i],
        assetContract: assetContracts[i],
        assetId: assetIds[i],
        currency: currencies[i],
        bidAmount: bidAmounts[i],
        startTime: startTimes[i],
        endTime: endTimes[i],
        signature: signatures[i]
      )
      
      if success
        successfulBidIds.push(bidIds[i])
      else
        failedBidIds.push(bidIds[i])
      end
    end
    
    require(successfulBidIds.length > 0, "No bids were successfully accepted")
    
    emit :MultipleBidResult,
      seller: msg.sender,
      successfulBidIds: successfulBidIds,
      failedBidIds: failedBidIds
  end
  
  function :acceptBidWithSignature, {
    bidId: :bytes32,
    bidder: :address,
    assetContract: :address,
    assetId: :uint256,
    currency: :address,
    bidAmount: :uint256,
    startTime: :uint256,
    endTime: :uint256,
    signature: :bytes
  }, :public do
    success = _acceptBidWithSignature(
      seller: msg.sender,
      bidId: bidId,
      bidder: bidder,
      assetContract: assetContract,
      assetId: assetId,
      currency: currency,
      bidAmount: bidAmount,
      startTime: startTime,
      endTime: endTime,
      signature: signature
    )
    
    require(success, "Seller no longer owns NFT")
    
    emit :BidAccepted,
      seller: msg.sender,
      bidder: bidder,
      assetContract: assetContract,
      assetId: assetId,
      bidAmount: bidAmount,
      currency: currency
  end
  
  
  function :_acceptBidWithSignature, {
    seller: :address,
    bidId: :bytes32,
    bidder: :address,
    assetContract: :address,
    assetId: :uint256,
    currency: :address,
    bidAmount: :uint256,
    startTime: :uint256,
    endTime: :uint256,
    signature: :bytes
  }, :internal, returns: :bool do
    whenNotPaused!
    
    signatureValid = signature.verifyTypedDataSignature(
      {Bid: [
        { name: "bidId", type: "bytes32" },
        { name: "bidder", type: "address" },
        { name: "assetContract", type: "address" },
        { name: "assetId", type: "uint256" },
        { name: "currency", type: "address" },
        { name: "bidAmount", type: "uint256" },
        { name: "startTime", type: "uint256" },
        { name: "endTime", type: "uint256" }
      ]},
      {
        bidId: bidId,
        bidder: bidder,
        assetContract: assetContract,
        assetId: assetId,
        currency: currency,
        bidAmount: bidAmount,
        startTime: startTime,
        endTime: endTime
      },
      verifyingContract: address(this),
      domainName: "FacetPort",
      domainVersion: "1",
      signer: bidder
    )
    
    require(signatureValid, "Invalid signature")
    
    require(block.timestamp >= startTime, "Current time is before the start time")
    require(block.timestamp <= endTime, "Current time is after the end time")
    require(!s.bidCancellations[bidder][bidId], "Bid has been cancelled by the bidder")
    require(startTime > s.userBidsOnAssetValidAfterTime[bidder][assetContract][assetId],
      "Start time is before the valid after time for the bidder's bid")
    require(startTime > s.userBidsValidAfterTime[bidder],
      "Start time is before the valid after time for the bidder's bid")  
    
    s.bidCancellations[bidder][bidId] = true
    
    return payRoyaltiesAndTransfer(
      assetContract: assetContract,
      assetId: assetId,
      seller: seller,
      buyer: bidder,
      price: bidAmount,
      currency: currency
    )
  end
  
  function :payRoyaltiesAndTransfer, {
    assetContract: :address,
    assetId: :uint256,
    seller: :address,
    buyer: :address,
    price: :uint256,
    currency: :address
  }, :internal, returns: :bool do
    currentOwner = ERC721(assetContract).ownerOf(assetId);
    
    return false unless currentOwner == seller
    
    (success, data) = assetContract.call(function: "supportsERC2981")
    
    royaltyAmount = 0
    
    if success && data == "true"
      (receiver, royaltyAmount) = ERC2981(assetContract).royaltyInfo(
        tokenId: assetId,
        salePrice: price
      )
      
      ERC20(currency).transferFrom(
        from: buyer,
        to: receiver,
        amount: royaltyAmount
      )
    end
    
    sellerAmount = price - royaltyAmount - computeFee(price)
    
    ERC20(currency).transferFrom(
      from: buyer,
      to: seller,
      amount: sellerAmount
    )
    
    ERC20(currency).transferFrom(
      from: buyer,
      to: owner(),
      amount: computeFee(price)
    )
    
    ERC721(assetContract).transferFrom(
      from: seller,
      to: buyer,
      id: assetId
    )
    
    return true
  end
  
  function :cancelListing, { listingId: :bytes32 }, :external do
    s.userListingCancellations[msg.sender][listingId] = true
    
    emit :ListingCancelled, seller: msg.sender, listingId: listingId
  end
  
  function :cancelAllListingsForAsset, { assetContract: :address, assetId: :uint256 }, :external do
    s.userListingsOfAssetValidAfterTime[msg.sender][assetContract][assetId] = block.timestamp
    
    emit :AllListingsOfAssetCancelledForUser,
      seller: msg.sender,
      assetContract: assetContract,
      assetId: assetId
  end
  
  function :cancelAllListingsOfUser, :external do
    s.userListingsValidAfterTime[msg.sender] = block.timestamp
    
    emit :AllListingsCancelledForUser, seller: msg.sender
  end
  
  function :cancelBid, { bidId: :bytes32 }, :external do
    s.bidCancellations[msg.sender][listingId] = true
    
    emit :BidCancelled, bidder: msg.sender, bidId: bidId
  end
  
  function :cancelAllBidsForAsset, { assetContract: :address, assetId: :uint256 }, :external do
    s.userBidsOnAssetValidAfterTime[msg.sender][assetContract][assetId] = block.timestamp
    
    emit :AllBidsOnAssetCancelledForUser,
      bidder: msg.sender,
      assetContract: assetContract,
      assetId: assetId
  end
  
  function :cancelAllBidsOfUser, :external do
    s.userBidsValidAfterTime[msg.sender] = block.timestamp
    
    emit :AllBidsCancelledForUser, bidder: msg.sender
  end
  
  function :computeFee, { amount: :uint256 }, :public, :view, returns: :uint256 do
    return (amount * s.feeBps).div(10_000)
  end
end
